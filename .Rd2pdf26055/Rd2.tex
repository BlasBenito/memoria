\documentclass[letterpaper]{book}
\usepackage[times,inconsolata,hyper]{Rd}
\usepackage{makeidx}
\usepackage[utf8]{inputenc} % @SET ENCODING@
% \usepackage{graphicx} % @USE GRAPHICX@
\makeindex{}
\begin{document}
\chapter*{}
\begin{center}
{\textbf{\huge memoria}}
\par\bigskip{\large \today}
\end{center}
\begin{description}
\raggedright{}
\inputencoding{utf8}
\item[Type]\AsIs{Package}
\item[Title]\AsIs{Quantifying ecological memory in palaeoecological datasets}
\item[Version]\AsIs{0.1.0}
\item[Author]\AsIs{Blas M. Benito}
\item[Maintainer]\AsIs{Blas M. Benito }\email{blasbenito@gmail.com}\AsIs{}
\item[Description]\AsIs{Provides tools to quantify ecological memory in long time series, including palaeoecological datasets, and simulated pollen curves generated by the virtualPollen package.}
\item[License]\AsIs{GPL-2 (see LICENSE file)}
\item[Encoding]\AsIs{UTF-8}
\item[LazyData]\AsIs{true}
\item[RoxygenNote]\AsIs{6.1.1}
\item[Imports]\AsIs{ggplot2, cowplot, viridis, HH, zoo, stringr, ranger, HH}
\end{description}
\Rdcontents{\R{} topics documented:}
\inputencoding{utf8}
\HeaderA{climate}{Dataframe with palaeoclimatic data.}{climate}
\keyword{datasets}{climate}
%
\begin{Description}\relax
A dataframe containing palaeoclimate data at 1 ky temporal resolution with the following columns:
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(climate)
\end{verbatim}
\end{Usage}
%
\begin{Format}
dataframe with 10 columns and 7986 rows.
\end{Format}
%
\begin{Details}\relax
\begin{itemize}

\item \emph{age}  in kiloyears before present (ky BP).
\item \emph{temperatureAverage} average annual temperature in Celsius degrees.
\item \emph{rainfallAverage} average annual precipitation in milimetres per day (mm/day).
\item \emph{temperatureWarmestMonth} average temperature of the warmest month, in Celsius degrees.
\item \emph{temperatureColdestMonth} average temperature of the coldest month, in Celsius degrees.
\item \emph{oxigenIsotope} delta O18, global ratio of stable isotopes in the sea floor, see \url{http://lorraine-lisiecki.com/stack.html} for further details.

\end{itemize}

\end{Details}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
\inputencoding{utf8}
\HeaderA{computeMemory}{Quantifies ecological memory with Random Forest}{computeMemory}
%
\begin{Description}\relax
Takes the oputput of \code{\LinkA{prepareLaggedData}{prepareLaggedData}} to fit the following model with Random Forest:

\eqn{p_{t} = p_{t-1} +...+ p_{t-n} + d_{t} + d_{t-1} +...+ d_{t-n} + r}{}

where:

\begin{itemize}

\item \eqn{d}{} is a driver (several drivers can be added).
\item \eqn{t}{} is the time of any given value of the response \emph{p}.
\item \eqn{t-1}{} is the lag number 1 (in time units).
\item \eqn{p_{t-1} +...+ p_{t-n}}{}  represents the endogenous component of ecological memory.
\item \eqn{d_{t-1} +...+ d_{t-n}}{}  represents the exogenous component of ecological memory.
\item \eqn{d_{t}}{} represents the concurrent effect of the driver over the response.
\item \eqn{r}{} represents a column of random values, used to test the significance of the variable importance scores returned by Random Forest.

\end{itemize}

\end{Description}
%
\begin{Usage}
\begin{verbatim}
computeMemory(
 lagged.data = NULL,
 drivers = NULL,
 response = "Response",
 add.random = TRUE,
 random.mode = "autocorrelated",
 repetitions = 10,
 subset.response = "none"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{lagged.data}] a lagged dataset resulting from \code{\LinkA{prepareLaggedData}{prepareLaggedData}}. See \code{\LinkA{laggedSimData}{laggedSimData}} as example.

\item[\code{drivers}] a string or vector of strings with variables to be used as predictors in the model (i.e. c("Suitability", "Driver.A"))

\item[\code{response}] character string, name of the response variable (typically, "Response\_0")

\item[\code{add.random}] if TRUE, adds a random term to the model, useful to assess the significance of the variable importance scores

\item[\code{random.mode}] either "white.noise" or "autocorrelated". See details.

\item[\code{repetitions}] integer, number of random forest models to fit

\item[\code{subset.response}] character string with values "up", "down" or "none", triggers the subsetting of the input dataset. "up" only models memory on cases where the response's trend is positive, "down" selectes cases with negative trends, and "none" selects all cases.

\item[\code{min.node.size}] integer, argument of the \LinkA{ranger}{ranger} function. Minimal number of samples to be allocated in a terminal node. Default is 5.

\item[\code{num.trees}] integer, argument of the \LinkA{ranger}{ranger} function. Number of regression trees to be fitted (size of the forest). Default is 2000.

\item[\code{mtry}] integer, argument of the \LinkA{ranger}{ranger} function. Number of variables to possibly split at in each node. Default is 2.

\item[\code{drivers}] a character string or vector of character strings with variables to be used as predictors in the model (i.e. c("Suitability", "Driver.A")). \strong{Important:} \code{drivers} names must not have the character "\_".
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function uses the \LinkA{ranger}{ranger} package to fit Random Forest models. It fits the model explained above as many times as defined in the argument \code{repetitions}. To test the statistical significance of the variable importance scores returned by random forest, on each repetition the model is fitted with a different \code{r} (random) term. If \code{random.mode} equals "autocorrelated", the random term will have a temporal autocorrelation, and if it equals "white.noise", it will be a pseudo-random sequence of numbers generated with \code{\LinkA{rnorm}{rnorm}}, with no temporal autocorrelation. The importance of the random sequence (as computed by random forest) is stored for each model run, and used as a benchmark to assess the importance of the other predictors used in the models. Importance values of other predictors that are above the median of the importance of the random term should be interpreted as non-random, and therefore, significant.
\end{Details}
%
\begin{Value}
A list with three 4 slots:
\begin{itemize}

\item \code{memory} dataframe with five columns:
\begin{itemize}

\item \code{Variable} character, names and lags of the different variables used to model ecological memory.
\item \code{median} numeric, median importance across \code{repetitions} of the given \code{Variable} according to Random Forest.
\item \code{sd} numeric, standard deviation of the importance values of the given \code{Variable} across \code{repetitions}.
\item \code{min} and \code{max} numeric, percentiles 0.05 and 0.95 of importance values of the given \code{Variable} across \code{repetitions}.

\end{itemize}

\item \code{R2} vector, values of pseudo R-squared value obtained for the Random Forest model fitted on each repetition. Pseudo R-squared is the Pearson correlation beteween the observed and predicted data.
\item \code{prediction} dataframe, with the same columns as the dataframe in the slot \code{memory}, with the median and confidence intervals of the predictions of all random forest models fitted.
\item \code{multicollinearity} multicollinearity analysis on the input data performed with \LinkA{vif}{vif}. A vif value higher than 5 indicates that the given variable is highly correlated with other variables.

\end{itemize}

\end{Value}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{plotMemory}{plotMemory}}, \code{\LinkA{extractMemoryFeatures}{extractMemoryFeatures}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
#loading data
data(laggedSimData)

#computing ecological memory
mem.output <- computeMemory(
 lagged.data = laggedSimData,
 drivers = "Driver.A",
 response = "Response",
 add.random = TRUE,
 random.mode = "autocorrelated",
 repetitions = 10,
 subset.response = "none"
 )

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{extractMemoryFeatures}{Extracts ecological memory features on the output of \code{\LinkA{computeMemory}{computeMemory}}.}{extractMemoryFeatures}
%
\begin{Description}\relax
It computes the following features of the ecological memory patterns returned by \code{\LinkA{computeMemory}{computeMemory}}:
\begin{itemize}

\item \code{memory strength} maximum difference in relative importance between each component (endogenous, exogenous, and concurrent) and the median of the random component. This is computed for exogenous, endogenous, and concurrent effect.
\item \code{memory length} proportion of lags over which the importance of a memory component is above the median of the random component. This is only computed for endogenous and exogenous memory.
\item \code{dominance} proportion of the lags above the median of the random term over which a memory component has a higher importance than the other component. This is only computed for endogenous and exogenous memory.

\end{itemize}

\end{Description}
%
\begin{Usage}
\begin{verbatim}
extractMemoryFeatures(
 analysis.output = NULL,
 exogenous.component = NULL,
 endogenous.component = NULL,
 sampling.subset = NULL
 )
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{analysis.output}] dataframe, output of \code{\LinkA{computeMemory}{computeMemory}}.

\item[\code{exogenous.component}] character string, name of the variable defining the exogenous component.

\item[\code{endogenous.component}] character string, string, name of the variable defining the endogenous component.

\item[\code{sampling.subset}] only used when analysis.output is the result of runExperiment(). String with the dataset type, one of: "Annual", "1cm", "2cm", "6cm", "10cm".
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A list with three 4 slots:
\end{Value}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{computeMemory}{computeMemory}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{laggedSimData}{Lagged data generated by \code{\LinkA{prepareLaggedData}{prepareLaggedData}}}{laggedSimData}
\keyword{datasets}{laggedSimData}
%
\begin{Description}\relax
A dataframe resulting from the application of \code{\LinkA{prepareLaggedData}{prepareLaggedData}} to the first slot of the list \code{\LinkA{simulation}{simulation}}. The order of the cases represent age. The first row contains the "older" sample, while the last row contains the "newest one". Therefore, for a lag equal to 1, any given case of the column \code{Response\_0} is aligned with the data of the row above it. The dataframe columns are:
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(laggedSimData)
\end{verbatim}
\end{Usage}
%
\begin{Format}
dataframe with 203 columns and 9900 rows.
\end{Format}
%
\begin{Details}\relax
\begin{itemize}

\item \emph{Response\_0} numeric, values of the Response (simulated pollen abundance in this case) for the lag 0 (meaning that data in this column has not been lagged). This column is used as response variable by the function \code{\LinkA{computeMemory}{computeMemory}}.
\item \emph{Response\_1-100} numeric, time delayed values of the response for different lags (in years). Considered together these columns represent the endogenous ecological memory.
\item \emph{Driver.A\_0} numeric, values of the variable Driver A for the lag 0 (no lag). This column represents the concurrent effect of the driver over the response.
\item \emph{Driver.A\_1-100} numeric, time delayed values of Driver.A for different lags (in years). Considered together these columns represent the exogenous ecological memory.

\end{itemize}

\end{Details}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{simulatePopulation}{simulatePopulation}}, \code{\LinkA{plotSimulation}{plotSimulation}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{mergePalaeoData}{Merges palaeoecological datasets with different time resolution.}{mergePalaeoData}
%
\begin{Description}\relax
It merges palaeoecological datasets with different time intervals between consecutive samples into a single dataset with samples separated by regular time intervals defined by the user
\end{Description}
%
\begin{Usage}
\begin{verbatim}
mergePalaeoData<-function(
datasets.list = NULL,
  time.column = NULL,
 interpolation.interval = NULL
 )
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{datasets.list}] list of dataframes, as in \code{datasets.list = list(climate = climate.dataframe, pollen = pollen.dataframe)}. The provided dataframes must have an age/time column with the same column name and the same units of time. Non-numeric columns in these dataframes are ignored.

\item[\code{time.column}] character string, name of the time/age column of the datasets provided in \code{datasets.list}.

\item[\code{interpolation.interval}] temporal resolution of the output data, in the same units as the age/time columns of the input data
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function fits a \code{\LinkA{loess}{loess}} model of the form \code{y \textasciitilde{} x}, where \code{y} is any column given by \code{columns.to.interpolate} and \code{x} is the column given by the \code{time.column} argument. The model is used to interpolate column \code{y} on a regular time series of intervals equal to \code{interpolation.interval}. All columns in every provided dataset go through this process to generate the final data with samples separated by regular time intervals. This function follows the same principles as \code{\LinkA{toRegularTime}{toRegularTime}}. Non-numeric columns are ignored, and absent from the output dataframe.
\end{Details}
%
\begin{Value}
A dataframe with every column of the initial dataset interpolated to a regular time grid of resolution defined by \code{interpolation.interval}. Column names follow the form datasetName.columnName, so the origin of columns can be tracked.
\end{Value}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{toRegularTime}{toRegularTime}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
#loading data
data(pollen)
data(climate)

x <- mergePalaeoData(
 datasets.list = list(
   pollen=pollen,
   climate=climate
 ),
 time.column = "age",
 interpolation.interval = 0.5
 )

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{palaeodata}{Dataframe with sample pollen and climate data.}{palaeodata}
\keyword{datasets}{palaeodata}
%
\begin{Description}\relax
A dataframe containing pollen and climate data interpolated at 0.1 ky temporal resolution with the following columns:
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(palaeodata)
\end{verbatim}
\end{Usage}
%
\begin{Format}
dataframe with 10 columns and 7986 rows.
\end{Format}
%
\begin{Details}\relax
\begin{itemize}

\item \emph{age} in years, at regular intervals of 100 years.
\item \emph{pinus} interpolated pollen counts of Pinus.
\item \emph{quercus} interpolated pollen counts of Quercus.
\item \emph{poaceae} interpolated pollen counts of Poaceae.
\item \emph{artemisia} interpolated pollen counts of Artemisia.
\item \emph{temperatureAverage} average annual temperature in Celsius degrees.
\item \emph{rainfallAverage} average annual precipitation in milimetres per day (mm/day).
\item \emph{temperatureWarmestMonth} average temperature of the warmest month, in Celsius degrees.
\item \emph{temperatureColdestMonth} average temperature of the coldest month, in Celsius degrees.
\item \emph{oxigenIsotope} delta O18, global ratio of stable isotopes in the sea floor, see \url{http://lorraine-lisiecki.com/stack.html} for further details.

\end{itemize}

\end{Details}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
\inputencoding{utf8}
\HeaderA{parameters}{Parameters of 2 virtual taxa.}{parameters}
\keyword{datasets}{parameters}
%
\begin{Description}\relax
A dataframe with 2 rows and 16 columns with the parameters of two virtual taxa. It was generated by \code{\LinkA{parametersDataframe}{parametersDataframe}} and \code{\LinkA{fixParametersTypes}{fixParametersTypes}}. It is meant to be used as input for \code{\LinkA{simulatePopulation}{simulatePopulation}}. It's columns are:
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(drivers)
\end{verbatim}
\end{Usage}
%
\begin{Format}
numeric vector of length 10000.
\end{Format}
%
\begin{Details}\relax
\begin{itemize}

\item label: to store names (character string) of the virtual taxa.
\item maximum.age: integer, maximum possible age of the individuals in years.
\item reproductive.age: integer, age of sexual maturity in years.
\item fecundity: integer, number of maximum viable seeds produced by a mature individual under fully suitable conditions.
\item growth.rate: numeric, parameter of the logistic growth function.
\item pollen.control: numeric in the interval [0, 1]. If 0, pollen productivity depends on environmental suitability only. The larger the number, biomass takes over environmental suitability in determining pollen productivity.
\item maximum.biomass: integer, maximum biomass of the individuals.
\item carrying.capacity: integer, maximum sum of biomass of the individuals. Very large carrying capacities plus a low maximum.biomass generates too many individuals for the simulation to remain efficient. Try to set carrying.capacity and maximum.biomass to carrying.capacity divided by biomass returns a number lower than 1000 (and even better if it is closer to 100).
\item driver.A.weight: numeric in the interval [0, 1], represents the relative influence of the driver on environmental suitability.
\item driver.B.weight: numeric in the interval [0, 1], represents the relative influence of the driver on environmental suitability. The sum of weights of drivers A and B should be 1.
\item niche.A.mean: numeric, in the same units as driver A. It is the mean of the normal function defining the response of the virtual taxa to driver A.
\item niche.A.sd: numeric, in the same units as driver A. It is the standard deviation of the normal function defining the response of the virtual taxa to driver A.
\item niche.B.mean: as above, but for driver B.
\item niche.B.sd: as above, but for driver B.
\item autocorrelation.length.A: numeric, only useful if several drivers generated with different autocorrelation lengths are available (and identified by the column \code{autocorrelation.length}) in the \code{drivers} argument provided to the \code{\LinkA{simulatePopulation}{simulatePopulation}} function.
\item autocorrelation.length.B: same as above.

\end{itemize}

\end{Details}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{parametersCheck}{parametersCheck}}, \code{\LinkA{parametersDataframe}{parametersDataframe}}, \code{\LinkA{simulatePopulation}{simulatePopulation}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{plotMemory}{Plots output of \code{\LinkA{computeMemory}{computeMemory}}}{plotMemory}
%
\begin{Usage}
\begin{verbatim}
plotMemory(
  memory.output = NULL,
  title = "Ecological memory pattern",
  legend.position = "right"
)
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{memory.output}] a dataframe with one time series per column.

\item[\code{title}] character string, name of the numeric column to be used as response in the model.

\item[\code{legend.position}] character vector, names of the numeric columns to be used as predictors in the model.

\item[\code{filename}] character string, name of output pdf file. If NULL or empty, no pdf is produced. It shouldn't include the extension of the output file.
\end{ldescription}
\end{Arguments}
%
\begin{Value}
A ggplot object.
\end{Value}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{computeMemory}{computeMemory}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
#loading data
data(laggedSimData)

mem.output <- computeMemory(
 lagged.data = laggedSimData,
 drivers = "Driver.A",
 response = "Response"
)

mem.output.plot <- plotMemory(
 memory.output = mem.output
 )

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{pollen}{Dataframe with pollen counts.}{pollen}
\aliasA{palaeodata}{pollen}{palaeodata}
\keyword{datasets}{pollen}
%
\begin{Description}\relax
A dataframe with the following columns:
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(pollen)
\end{verbatim}
\end{Usage}
%
\begin{Format}
dataframe with 10 columns and 7986 rows.
\end{Format}
%
\begin{Details}\relax
\begin{itemize}

\item \emph{age} in kiloyears before present (ky BP).
\item \emph{pinus} pollen counts of Pinus.
\item \emph{quercus} pollen counts of Quercus.
\item \emph{poaceae} pollen counts of Poaceae.
\item \emph{artemisia} pollen counts of Artemisia.

\end{itemize}

\end{Details}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
\inputencoding{utf8}
\HeaderA{prepareLaggedData}{Organizes time series data into lags.}{prepareLaggedData}
%
\begin{Description}\relax
Takes a multivariate time series, where at least one variable is meant to be used as a response while the others are meant to be used as predictors in a model, and organizes it in to quantify ecological memory through models of the form:
\eqn{p_{t} ~ p_{t-1} +...+ p_{t-n} + d_{t} + d_{t-1} +...+ d_{t-n}}{}

where:

\begin{itemize}

\item \eqn{d}{} is a driver (several drivers can be added).
\item \eqn{t}{} is the time of any given value of the response \emph{p}.
\item \eqn{t-1}{} is the lag number 1 (in time units).
\item \eqn{p_{t-1} +...+ p_{t-n}}{}  represents the endogenous component of ecological memory.
\item \eqn{d_{t-1} +...+ d_{t-n}}{}  represents the exogenous component of ecological memory.
\item \eqn{d_{t}}{} represents the concurrent effect of the driver over the response.

\end{itemize}

\end{Description}
%
\begin{Usage}
\begin{verbatim}
prepareLaggedData(
  input.data = NULL,
  response = NULL,
  drivers = NULL,
  time = NULL,
  oldest.sample = "first",
  lags = seq(0, 200, by=20),
  time.zoom=NULL,
  scale=FALSE
  )
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{input.data}] a dataframe with one time series per column.

\item[\code{response}] character string, name of the numeric column to be used as response in the model.

\item[\code{drivers}] character vector, names of the numeric columns to be used as predictors in the model.

\item[\code{time}] character vector, name of the numeric column with the time/age.

\item[\code{oldest.sample}] character string, either "first" or "last". When "first", the first row taken as the oldest case of the time series and the last row is taken as the newest case, so ecological memory flows from the first to the last row of \code{input.data}. When "last", the last row is taken as the oldest sample, and this is the mode that should be used when \code{input.data} represents a palaeoecological dataset. Default behavior is "first".

\item[\code{lags}] numeric vector of positive integers, lags to be used in the equation. Generally, a regular sequence of numbers, in the same units as \code{time}. The use \code{\LinkA{seq}{seq}} to define it is highly recommended. If 0 is absent from lags, it is added automatically to allow the consideration of a concurrent effect. Lags should take into account the temporal resolution of the data, and be aligned to it. For example, if the interval between consecutive samples is 100 years, lags should be something like \code{0, 100, 200, 300}. Lags can also be multiples of the time resolution, such as \code{0, 200, 400, 600} (in the case time resolution is 100 years).

\item[\code{time.zoom}] numeric vector of two numbers of the \code{time} column used to subset the data if desired.

\item[\code{scale}] boolean, if TRUE, applies the \code{\LinkA{scale}{scale}} function to normalize the data. Required if the lagged data is going to be used to fit linear models.
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
The function interprets the \code{time} column as an index representing the
\end{Details}
%
\begin{Value}
A dataframe with columns representing time-delayed values of the drivers and the response. Column names have the lag number as a suffix. The response variable is identified in the output as "Response\_0".
\end{Value}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{computeMemory}{computeMemory}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
#loading data
data(simulation)

#adding lags
sim.lags <- prepareLaggedData(
  input.data = simulation[[1]],
  response = "Pollen",
  drivers = "Driver",
  time = "Time",
  oldest.sample = "first",
  lags = seq(0, 200, by=20),
  time.zoom=NULL,
  scale=FALSE
  )

\end{ExampleCode}
\end{Examples}
\inputencoding{utf8}
\HeaderA{simulation}{List with two simulation outputs.}{simulation}
\keyword{datasets}{simulation}
%
\begin{Description}\relax
A list of dataframes with two slots, output of \code{\LinkA{simulatePopulation}{simulatePopulation}}. Each slot corresponds to a virtual taxon from the \code{\LinkA{parameters}{parameters}} dataframe. Each dataframe has the following columns:
\end{Description}
%
\begin{Usage}
\begin{verbatim}
data(simulation)
\end{verbatim}
\end{Usage}
%
\begin{Format}
numeric vector of length 10000.
\end{Format}
%
\begin{Details}\relax
\begin{itemize}

\item \emph{Time} integer, ages in years. Negative ages indicate the burn-in period.
\item \emph{Pollen} numeric, pollen counts
\item \emph{Population.mature} numeric, number of mature individuals.
\item \emph{Population.immatre} numeric, number of immature individuals.
\item \emph{Population.viable.seeds} numeric, number of viable seeds generated each year.
\item \emph{Suitability} numeric, environmental suitability computed from the driver by the normal function/s defining the taxon niche.
\item \emph{Biomass.total} numeric, overall biomass of the population.
\item \emph{Biomass.mature} numeric, sum of biomass of mature individuals.
\item \emph{Biomass.immature} numeric, sum of biomass of immature individuals.
\item \emph{Mortality.mature} numeric, number of mature individuals dead each year.
\item \emph{Mortality.immature} numeric, same as above for immature individuals.
\item \emph{Driver.A} numeric, values of driver A.
\item \emph{Driver.B} numeric, values of driver B, if available, and NA otherwise.
\item \emph{Period} qualitative, with value "Burn-in" for burn-in period, and "Simulation" otherwise.

\end{itemize}

\end{Details}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{simulatePopulation}{simulatePopulation}}, \code{\LinkA{plotSimulation}{plotSimulation}}
\end{SeeAlso}
\inputencoding{utf8}
\HeaderA{toRegularTime}{Reinterpolates aggregated simulations into regular time.}{toRegularTime}
%
\begin{Description}\relax
Takes the output of \code{\LinkA{aggregateSimulation}{aggregateSimulation}}, and interpolates it into a regular time grid.
\end{Description}
%
\begin{Usage}
\begin{verbatim}
toRegularTime(
  x,
  time.column="Time",
  interpolation.interval,
  columns.to.interpolate=c("Suitability", "Driver.A", "Pollen")
  )
\end{verbatim}
\end{Usage}
%
\begin{Arguments}
\begin{ldescription}
\item[\code{x}] list of dataframes (generally the output of \code{\LinkA{aggregateSimulation}{aggregateSimulation}}) or single dataframe  with irregular time series.

\item[\code{time.column}] character string, default value is "Time".

\item[\code{interpolation.interval}] integer, in years, time length encompassed by each sample.

\item[\code{columns.to.interpolate}] character string or character vector, columns of simulation output to be interpolated. Any subset of: "Pollen", "Population.mature", "Population.immature", "Population.viable.seeds", "Suitability", "Biomass.total", "Biomass.mature", "Biomass.immature", "Mortality.mature", "Mortality.immature", "Driver.A", "Driver.B".
\end{ldescription}
\end{Arguments}
%
\begin{Details}\relax
This function fits a \code{\LinkA{loess}{loess}} model of the form \code{y \textasciitilde{} x}, where \code{y} is any column given by \code{columns.to.interpolate} and \code{x} is the column given by the \code{time.column} argument. The model is used to interpolate column \code{y} on a regular time series of intervals equal to \code{interpolation.interval}. If \code{x} is a matrix-like list returned by \code{\LinkA{aggregateSimulation}{aggregateSimulation}} (on results of \code{\LinkA{simulateAccumulationRate}{simulateAccumulationRate}} and \code{\LinkA{simulatePopulation}{simulatePopulation}}), the first column of the matrix will already have a regular time column, and therefore nothing will be done with this column of the list.
\end{Details}
%
\begin{Value}
If \code{x} is a list of dataframes, the function returns a list with the same structure as the input list. If \code{x} is a dataframe, the function returns a dataframe. In any case, output dataframes have the columns "Time" (now regular), and any column listed in \code{columns.to.interpolate}.
\end{Value}
%
\begin{Author}\relax
Blas M. Benito  <blasbenito@gmail.com>
\end{Author}
%
\begin{SeeAlso}\relax
\code{\LinkA{simulateAccumulationRate}{simulateAccumulationRate}}, \code{\LinkA{aggregateSimulation}{aggregateSimulation}}
\end{SeeAlso}
%
\begin{Examples}
\begin{ExampleCode}
#loading data
data(simulation)

#generating accumulation rate
acc.rate <- simulateAccumulationRate(
 seed=50,
 time=1:1000,
 output.min=10,
 output.max=40,
 direction=1,
 plot=TRUE
 )

#aggregating simulated data
sim.output.aggregated <- aggregateSimulation(
 simulation.output=sim.output,
 accumulation.rate=acc.rate,
 sampling.intervals=3
 )

#comparing simulations
sim.output.regular <- toRegularTime(
 x=sim.output.aggregated,
 time.column="Time",
 interpolation.interval=20,
 columns.to.interpolate=c("Driver.A", "Pollen")
 )

\end{ExampleCode}
\end{Examples}
\printindex{}
\end{document}
