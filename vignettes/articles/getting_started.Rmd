---
title: "Getting Started"
output: 
  rmarkdown::html_document:
    toc: true
    toc_title: "Content"
    source: false
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 9,
  fig.height = 4,
  out.width = "100%"
)
```

This article walks through the complete `memoria` workflow for quantifying ecological memory in time series data consisting of at least one response and one predictor.

## Ecological Memory

The package `memoria` helps quantify how past and concurrent events shape the state of a system. This concept is summarized in the figure below:

![Ecological Memory](ecological_memory.png)
The blue and green curves represent the values of a biotic response `y` and a driver `x` over time. The vertical line `T` represents the *current* time, while `T - lag` represents a previous time. The arrows represent *influence*, as follows:

 + **Endogenous memory**: is the effect of past `y` on present `y`.
 + **Exogenous memory**: is the effect of past `x` on present `y`.
 + **Concurrent effect**: is the effect of present `x` on present `y`.
 
To assess these effects, `memoria` generates the lagged data and trains the model

$$y_{T} = y_{T-1} + \ldots + y_{T-n} + x_{T} + x_{T-1} + \ldots + x_{T-n} + r_{T}$$

Where:

- $y$ and $x$ are the response and the driver.
- $T$ is the "current" time, and $T-1$ to  $T-n$, are the time lags.
- $y_{T-1} + \ldots + y_{T-n}$ represents the **endogenous memory** across lags.
- $x_{T-1} + \ldots + x_{T-n}$ represents the **exogenous memory** across lags.
- $x_{T}$ represents the **concurrent effect**.
- $r_{T}$ is a random term used to assess statistical significance.

The ecological memory pattern is quantified using **permutation importance** from Random Forest models. For each predictor, the algorithm shuffles its values and measures the decrease in predictive accuracy. Larger decreases indicate stronger influence on the response.

To visualize ecological memory, the package `memoria` plots permutation importance scores across time lags.

![Ecological Memory](memory_plot.png)

Where:
  
  + `a`: strength of the concurrent effect (highlighted by a grey box).
  + `b` and `c`: strength of the exogenous and endogenous memory.
  + `d` and `e`: length of the exogenous and endogenous memory.
  + `f` and `g`: dominance across lags of the endogenous and exogenous memory.

The following sections demonstrate how to implement this workflow in R using the `memoria` package.

## Setup

```{r install-deps, include = FALSE}
for (pkg in c("knitr", "distantia", "dplyr")) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    install.packages(pkg)
  }
}
library(knitr)
```

```{r load-packages, message = FALSE, warning = FALSE}
library(memoria)
library(distantia)
library(ggplot2)
library(dplyr)
```


## Workflow

The typical workflow involves time series with one response variable and one or several drivers.

The package `memoria` has two example datasets, one with responses and one with drivers:

- **pollen**: irregular time series with 639 samples and four pollen types (Pinus, Quercus, Poaceae, Artemisia).

```{r, fig.width=8, fig.height=6}
data(pollen, package = "memoria")

pollen |> 
  distantia::tsl_init(
    time_column = "age"
  ) |> 
  distantia::tsl_plot(
    ylim = "relative",
    guide = FALSE
  )
```

- **climate**: regular time series with 800 samples taken every 1000 years, with climate variables (temperature, rainfall, etc.)

```{r, fig.width=8, fig.height=8}
data(climate, package = "memoria")

climate |> 
  distantia::tsl_init(
    time_column = "age"
  ) |> 
  distantia::tsl_plot(
    ylim = "relative",
    guide = FALSE,
    line_color = "blue4"
  )
```

### Align Datasets

The package `memoria` requires the input time series to be regular, but `pollen` is irregular, with a range of time intervals between `r min(diff(pollen$age))` and `r max(diff(pollen$age))`.

To homogenize both datasets, below we use linear interpolation with time to align `pollen` with `climate`.

```{r}
df <- memoria::alignTimeSeries(
  datasets.list = list(
    pollen = pollen,
    climate = climate
  ),
  time.column = "age",
  interpolation.interval = 1
)

nrow(df)
range(diff(df$age)) #1000 years
colnames(df)
```


Now that the responses and the drivers are at the same resolution, we just need to select the data we want to play with.

```{r}
df <- df |> 
  dplyr::transmute(
    time = age,
    quercus = pollen.quercus,
    rain = climate.rainfallAverage,
    temp = climate.temperatureAverage
  )
```


### Create lagged data

The `lagTimeSeries()` function organizes data into the lag structure required by the model. Each sample of the response is aligned with antecedent values of itself and the drivers. In this case we use lags 1 to 10, which correspond with 1000 to 10000 years.

```{r prepare-lagged}
quercus_lags <- lagTimeSeries(
  input.data = df,
  response = "quercus",
  drivers = c("rain", "temp"),
  time = "time",
  oldest.sample = "last",
  lags = seq(from = 1, to = 10, by = 1)
)
```

**Note on `oldest.sample`:** Set to `"last"` when the oldest sample is at the bottom of the dataframe (typical palaeoecological convention). Set to `"first"` if the oldest sample is at the top.

The output columns follow a naming convention:

```{r}
dplyr::glimpse(quercus_lags)
```

```{r, fig.width=8, fig.height=6}
quercus_lags |> 
  dplyr::select(
    quercus__0,
    quercus__5,
    quercus__10,
    time
  ) |> 
  dplyr::filter(
    time <= 100
  ) |>
  distantia::tsl_init(
    time_column = "time"
  ) |> 
  distantia::tsl_plot()
```


### Ecological Memory Analysis

The `computeMemory()` function fits Random Forest models on the lagged data. It measures variable importance using permutation, which is robust to multicollinearity and temporal autocorrelation.

Two benchmark modes are available for significance testing:

- `"white.noise"`: Random values without temporal structure (faster)
- `"autocorrelated"`: Random walk with temporal structure (more conservative, **recommended**)

The model runs multiple times (`repetitions`), regenerating the random term each time, then computes percentiles of importance scores.

```{r compute-memory-whitenoise, fig.width = 5, fig.height = 2}
quercus_memory <- memoria::computeMemory(
  lagged.data = quercus_lags,
  random.mode = "autocorrelated",
  repetitions = 100
)
```

We can visualize the results with `plotMemory()`.

```{r compute-memory-autocor, fig.width = 5, fig.height = 3}
memoria::plotMemory(quercus_memory)
```

The plot shows all ecological memory components of this dataset.

- **Endogenous memory** ("quercus" curve): shows the importance of the past pollen abundance in predicting current pollen abundance. In this case, this is the most important memory component, with a lag of ~5000 years.

- **Significance test** ("random" curve): shows the median importance scores of randomly generated variables. Defines a baseline helpful to know when a given memory component explains the response better (above the yellow line) or worse than random.

- **Concurrent effect** ("temp" and "rain" at lag 0): importance of the current driver values to predict the response. In this case, the *concurrent effect* is much weaker than the *endogenous memory*.

- **Exogenous memory** ("temp" and "rain" at lag > 0): importance of the past driver values in explaining the current response values. According to the plot, temperature is the strongest component of the exogenous memory, with a lag of almost ~4000 years.

The `extractMemoryFeatures()` function transforms the plot results into quantitative features:

```{r extract-features}
extractMemoryFeatures(
  memory.pattern = quercus_memory
) |> 
  dplyr::glimpse()
```

The output contains eight features organized in three groups:

The **strength** values (scaled to [0, 1] by default) measure the peak importance of each memory component relative to the median of the random baseline.

The **length** values (proportion in [0, 1]) measure how far into the past each memory component remains above the random baseline. In this case, the endogenous memory component is above the baseline for half of the lags.

The **dominance** values (proportion in [0, 1]) measure whether endogenous or exogenous memory prevails across significant lags. In this case, the exogenous memory is never above the endogenous one, hence it has zero dominance.

## Summary

The complete workflow:

1. `alignTimeSeries()` - Align datasets with different resolutions.
2. `lagTimeSeries()` - Create lag structure.
3. `computeMemory()` - Fit Random Forest and compute importance.
4. `plotMemory()` - Visualize the memory pattern.
5. `extractMemoryFeatures()` - Quantify memory characteristics.
